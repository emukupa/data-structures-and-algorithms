# data-structures-and-algorithms

## Data types
### Primitive types
- [ ] Boolean, true or false.
- [ ] Character
- [ ] Floating-point numbers, limited precision rational number values.
    * Including Single precision and Double precision IEEE 754 Floats, among others
- [ ] Fixed-point numbers
- [ ] Integer, integral or fixed-precision values.
- [ ] Reference (also called a pointer or handle), a small value referring to another object's address in memory, possibly a much larger one.
- [ ] Enumerated type, a small set of uniquely named values.

### Composite types or non-primitive type
- [ ] Array
- [ ] Record (also called tuple or structure)
- [ ] String, a sequence of characters.
- [ ] Union
- [ ] Tagged union (also called variant, variant record, discriminated union, or disjoint union)

### Abstract data types
- [ ] Container
- [ ] List
- [ ] Associative array
- [ ] Multimap
- [ ] Heap
- [ ] Set
- [ ] Multiset (bag)
- [ ] Stack
- [ ] Queue
- [ ] Double-ended queue
- [ ] Priority queue
- [ ] Tree
- [ ] Graph

## Linear data structures
A data structure is said to be linear if its elements form a sequence.

### Arrays
- [ ] Array
- [ ] Bit array
- [ ] Bit field
- [ ] Bitboard
- [ ] Bitmap
- [ ] Circular buffer
- [ ] Control table
- [ ] Image
- [ ] Dope vector
- [ ] Dynamic array
- [ ] Gap buffer
- [ ] Hashed array tree
- [ ] Heightmap
- [ ] Lookup table
- [ ] Matrix
- [ ] Parallel array
- [ ] Sorted array
- [ ] Sparse matrix
- [ ] Iliffe vector
- [ ] Variable-length array

### Lists
- [ ] Doubly linked list
- [ ] Array list
- [ ] Linked list
- [ ] Self-organizing list
- [ ] Skip list
- [ ] Unrolled linked list
- [ ] VList
- [ ] Conc-tree list
- [ ] Xor linked list
- [ ] Zipper
- [ ] Doubly connected edge list also known as half-edge
- [ ] Difference list
- [ ] Free list

## Trees
Tree (data structure)

### Binary trees
- [ ] AA tree
- [ ] AVL tree
- [ ] Binary search tree
- [ ] Binary tree
- [ ] Cartesian tree
- [ ] Left-child right-sibling binary tree
- [ ] Order statistic tree
- [ ] Pagoda
- [ ] Randomized binary search tree
- [ ] Red–black tree
- [ ] Rope
- [ ] Scapegoat tree
- [ ] Self-balancing binary search tree
- [ ] Splay tree
- [ ] T-tree
- [ ] Tango tree
- [ ] Threaded binary tree
- [ ] Top tree
- [ ] Treap
- [ ] WAVL tree
- [ ] Weight-balanced tree

### B-trees
- [ ] B-tree
- [ ] B+ tree
- [ ] B*-tree
- [ ] B sharp tree
- [ ] Dancing tree
- [ ] 2-3 tree
- [ ] 2-3-4 tree
- [ ] Queap
- [ ] Fusion tree
- [ ] Bx-tree
- [ ] AList

### Heaps
- [ ] Heap
- [ ] Binary heap
- [ ] B-heap
- [ ] Weak heap
- [ ] Binomial heap
- [ ] Fibonacci heap
- [ ] AF-heap
- [ ] Leonardo Heap
- [ ] 2-3 heap
- [ ] Soft heap
- [ ] Pairing heap
- [ ] Leftist heap
- [ ] Treap
- [ ] Beap
- [ ] Skew heap
- [ ] Ternary heap
- [ ] D-ary heap
- [ ] Brodal queue

### Trees
In these data structures each tree node compares a bit slice of key values.
- [ ] Trie
- [ ] Radix tree
- [ ] Suffix tree
- [ ] Suffix array
- [ ] Compressed suffix array
- [ ] FM-index
- [ ] Generalised suffix tree
- [ ] B-trie
- [ ] Judy array
- [ ] X-fast trie
- [ ] Y-fast trie
- [ ] Merkle tree
- [ ] Ctrie

### Multiway trees
- [ ] Ternary tree
- [ ] K-ary tree
- [ ] And–or tree
- [ ] (a,b)-tree
- [ ] Link/cut tree
- [ ] SPQR-tree
- [ ] Spaghetti stack
- [ ] Disjoint-set data structure
- [ ] Fusion tree
- [ ] Enfilade
- [ ] Exponential tree
- [ ] Fenwick tree
- [ ] Van Emde Boas tree
- [ ] Rose tree

### Space-partitioning trees
These are data structures used for space partitioning or binary space partitioning.
- [ ] Segment tree
- [ ] Interval tree
- [ ] Range tree
- [ ] Bin
- [ ] K-d tree
- [ ] Implicit k-d tree
- [ ] Min/max k-d tree
- [ ] Relaxed k-d tree
- [ ] Adaptive k-d tree
- [ ] Quadtree
- [ ] Octree
- [ ] Linear octree
- [ ] Z-order
- [ ] UB-tree
- [ ] R-tree
- [ ] R+ tree
- [ ] R* tree
- [ ] Hilbert R-tree
- [ ] X-tree
- [ ] Metric tree
- [ ] Cover tree
- [ ] M-tree
- [ ] VP-tree
- [ ] BK-tree
- [ ] Bounding interval hierarchy
- [ ] Bounding volume hierarchy
- [ ] BSP tree
- [ ] Rapidly exploring random tree

### Application-specific trees
- [ ] Abstract syntax tree
- [ ] Parse tree
- [ ] Decision tree
- [ ] Alternating decision tree
- [ ] Minimax tree
- [ ] Expectiminimax tree
- [ ] Finger tree
- [ ] Expression tree
- [ ] Log-structured merge-tree
- [ ] Lexicographic Search Tree

## Hashes
- [ ] Bloom filter
- [ ] Count-Min sketch
- [ ] Distributed hash table
- [ ] Double hashing
- [ ] Dynamic perfect hash table
- [ ] Hash array mapped trie
- [ ] Hash list
- [ ] Hash table
- [ ] Hash tree
- [ ] Hash trie
- [ ] Koorde
- [ ] Prefix hash tree
- [ ] Rolling hash
- [ ] MinHash
- [ ] Quotient filter
- [ ] Ctrie

## Graphs
- [ ] Graph
- [ ] Adjacency list
- [ ] Adjacency matrix
- [ ] Graph-structured stack
- [ ] Scene graph
- [ ] Binary decision diagram
- [ ] Zero-suppressed decision diagram
- [ ] And-inverter graph
- [ ] Directed graph
- [ ] Directed acyclic graph
- [ ] Propositional directed acyclic graph
- [ ] Multigraph
- [ ] Hypergraph

## Other
- [ ] Lightmap
- [ ] Winged edge
- [ ] Quad-edge
- [ ] Routing table
- [ ] Symbol table

## ALgorithms
### General
- [ ] Reverse a String
- [ ] Factorialize a Number
- [ ] Check for Palindromes
- [ ] Find the Longest Word in a String 
- [ ] Title Case a Sentence
- [ ] Return Largest Numbers in Arrays
- [ ] Confirm the Ending
- [ ] Repeat a string repeat a string
- [ ] Truncate a string
- [ ] Chunky Monkey
- [ ] Slasher Flick
- [ ] Mutations
- [ ] Falsy Bouncer 
- [ ] Seek and Destroy 
- [ ] Where do I belong 
- [ ] Caesars Cipher 

### Prime Numbers and Prime Factorization [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Primality Test | Set 1 (Introduction and School Method)
- [ ] Primality Test | Set 2 (Fermat Method)
- [ ] Primality Test | Set 3 (Miller–Rabin)
- [ ] Sieve of Eratosthenes
- [ ] Segmented Sieve
- [ ] Wilson’s Theorem
- [ ] Prime Factorisation
- [ ] Pollard’s rho algorithm

### Geometrical and Network Flow Algorithms [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Convex Hull
- [ ] Graham Scan
- [ ] Line Intersection
- [ ] Interval Tree
- [ ] Matrix Exponentiation and this
- [ ] Maxflow Ford Furkerson Algo and Edmond Karp Implementation
- [ ] Min cut
- [ ] Stable Marriage Problem
- [ ] Hopcroft–Karp Algorithm for Maximum Matching
- [ ] Dinic’s algo and e-maxx

### Modulo Arithmetic Algorithms [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Basic and Extended Euclidean algorithms
- [ ] Euler’s Totient Function
- [ ] Modular Exponentiation
- [ ] Modular Multiplicative Inverse
- [ ] Chinese remainder theorem Introduction
- [ ] Chinese remainder theorem and Modulo Inverse Implementation
- [ ] nCr%m and this.

### Data Structures Algo [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Binary Indexed Tree or Fenwick tree
- [ ] Segment Tree (RMQ, Range Sum and Lazy Propagation)
- [ ] K-D tree (See insert, minimum and delete)
- [ ] Union Find Disjoint Set (Cycle Detection and By Rank and Path Compression)
- [ ] Tries
- [ ] Suffix array (this, this and this)
- [ ] Sparse table
- [ ] Suffix automata
- [ ] Suffix automata II
- [ ] LCA and RMQ

### Searching
- [ ] linear 
- [ ] Depth First Search (DFS) 
- [ ] binary 
- [ ] Breadth First Search (BFS)

### Sorting [ref](https://towardsdatascience.com/top-algorithms-and-data-structures-you-really-need-to-know-ab9a2a91c7b5)
- [ ] Quick sort
- [ ] Merge sort
- [ ] Heap sort
- [ ] Intro sort
- [ ] Insertion sort
- [ ] Bubble sort
- [ ] Selection sort
- [ ] Counting sort
- [ ] Radix sort
- [ ] Bucket sort
- [ ] Order Statistics
- [ ] KMP algorithm
- [ ] Rabin karp
- [ ] Z’s algorithm
- [ ] Aho Corasick String Matching
- [ ] Counting Sort
- [ ] Manacher’s algorithm: Part 1, Part 2 and Part 3

### Graph Algorithms [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Breadth First Search (BFS)
- [ ] Depth First Search (DFS)
- [ ] Shortest Path from source to all vertices **Dijkstra**
- [ ] Shortest Path from every vertex to every other vertex **Floyd Warshall**
- [ ] Minimum Spanning tree **Prim**
- [ ] Minimum Spanning tree **Kruskal**
- [ ] Topological Sort
- [ ] Johnson’s algorithm
- [ ] Articulation Points (or Cut Vertices) in a Graph
- [ ] Bridges in a graph

### Dynamic Programming [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Longest Common Subsequence
- [ ] Longest Increasing Subsequence
- [ ] Edit Distance
- [ ] Minimum Partition
- [ ] Ways to Cover a Distance
- [ ] Longest Path In Matrix
- [ ] Subset Sum Problem
- [ ] Optimal Strategy for a Game
- [ ] 0-1 Knapsack Problem
- [ ] Assembly Line Scheduling

### Miscellaneous [source](https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/)
- [ ] Counting Inversions
- [ ] Counting Inversions using BIT
- [ ] logarithmic exponentiation
- [ ] Square root of an integer
- [ ] Heavy light Decomposition , this and this
- [ ] Matrix Rank
- [ ] Gaussian Elimination to Solve Linear Equations
- [ ] Hungarian algorithm
- [ ] Link cut
- [ ] Mo’s algorithm and this
- [ ] Factorial of a large number in C++
- [ ] Factorial of a large number in Java+
- [ ] Russian Peasant Multiplication
- [ ] Catalan Number
